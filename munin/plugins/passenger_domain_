#!/usr/bin/env ruby
#
# Copyright (C) 2010  Kouhei Sutou <kou@clear-code.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#%# family=auto
#%# capabilities=autoconf suggest

require 'English'
require 'rubygems'

mode = ARGV[0]

def passenger_status_path(gem_path)
  File.join(gem_path, "bin", "passenger-status")
end

@label = ENV["label"]
@pid_file = ENV["pid_file"]
@ruby = ENV["ruby"] || Gem.ruby
@gem_path = ((ENV["GEM_HOME"] || '').split(/:/) + Gem.path).find do |path|
  File.exist?(passenger_status_path(path))
end

if @label
  parameter_prefix = /\Apassenger_(?:#{@label}_)?domain_/
else
  parameter_prefix = /\Apassenger_domain_/
end
parameter = File.basename($0).gsub(parameter_prefix, '')
if /_(sessions|processed|uptime)\z/ =~ parameter
  @domain = $PREMATCH
  @type = $1
  @domain = nil if @domain and @domain.empty?
else
  @domain = @type = nil
end

def passenger_status
  if @pid_file
    unless File.readable?(@pid_file)
      return [false, "PID file isn't readable: #{@pid_file}"]
    end
    pid = File.read(@pid_file).strip
  else
    pid = nil
  end
  result = `#{@ruby} #{passenger_status_path(@gem_path)} #{pid}`
  [$?.success?, result]
end

def parse_uptime(uptime)
  uptime_in_minutes = 0
  if /\A(?:(?:(\d+)h\s+)?(\d+)m\s+)?(\d+)s\z/ =~ uptime
    hours = $1.to_i
    minutes = $2.to_i
    seconds = $3.to_i
    uptime_in_minutes = minutes + hours * 60
  end
  uptime_in_minutes
end

def extract_domain(path)
  components = path.split(/\//)
  ignore_components = ["current"]
  while ignore_components.include?(components.last)
    components.pop
  end
  components.pop
end

def parse_result(result)
  sections = {}
  section = nil
  domain = nil
  result.each_line do |line|
    case section
    when "Domains"
      case line.chomp
      when /\A(.+):\s*\z/
        path = $1
        domain = extract_domain(path)
        sections[section] << [domain, []]
      when /\A\s+PID:\s+(\d+)\s+
                 Sessions:\s+(\d+)\s+
                 Processed:\s+(\d+)\s+
                 Uptime:\s+(.+)\z/x
        pid = $1.to_i
        sessions = $2.to_i
        processed = $3.to_i
        uptime = parse_uptime($4)
        _domain, processes = sections[section].last
        processes << {
          :pid => pid,
          :sessions => sessions,
          :processed => processed,
          :uptime => uptime
        }
      end
    else
      if /-+\s+(.+)\s+-+/ =~ line
        section = $1
        sections[section] = []
      end
    end
  end
  sections
end

def vlabel
  case @type
  when "sessions"
    "number of processing sessions"
  when "processed"
    "number of processed sessions"
  when "uptime"
    "uptime by minutes"
  else
    "unknown"
  end
end

def config
  success, result = passenger_status
  unless success
    puts result
    exit(false)
  end

  if @label
    title = "Passenger: #{@label}: #{@type}: #{@domain}"
  else
    title = "Passenger: #{@type}: #{@domain}"
  end
  sections = parse_result(result)
  puts(<<-EOC)
graph_title #{title}
graph_category passenger
graph_info Passenger #{@domain} #{@type}
graph_vlabel #{vlabel}

EOC
  sections["Domains"].each do |domain, processes|
    next if domain != @domain
    processes.sort_by do |attributes|
      attributes[:pid]
    end.each_with_index do |attributes, i|
      puts("#{@type}#{i}.label #{i} (PID #{attributes[:pid]})")
    end
  end
end

def report
  success, result = passenger_status
  unless success
    puts result
    exit(false)
  end

  sections = parse_result(result)
  sections["Domains"].each do |domain, processes|
    next if domain != @domain
    processes.sort_by do |attributes|
      attributes[:pid]
    end.each_with_index do |attributes, i|
      puts("#{@type}#{i}.value #{attributes[@type.to_sym]}")
    end
  end
end

case mode
when "auto", "autoconf", "detect"
  success, result = passenger_status
  if success
    puts "yes"
    exit(true)
  else
    puts "no (#{result})"
    exit(false)
  end
when "suggest"
  success, result = passenger_status
  if success
    sections = parse_result(result)
    domains = sections["Domains"]
    if domains
      domains.each do |domain, processes|
        puts "#{domain}_sessions"
        puts "#{domain}_processed"
        puts "#{domain}_uptime"
      end
      exit(true)
    else
      puts "no domain: #{result.inspect}"
      exit(false)
    end
  else
    puts result
    exit(false)
  end
else
  if @domain.nil?
    puts "no domain"
    exit(false)
  end
  if @type.nil?
    puts "no type: #{@domain}"
    exit(false)
  end
  case mode
  when "config"
    config
  else
    report
  end
end
